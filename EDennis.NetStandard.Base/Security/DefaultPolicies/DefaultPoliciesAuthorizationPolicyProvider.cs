using IdentityModel;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authorization.Infrastructure;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace EDennis.NetStandard.Base {

    /// <summary>
    /// Provides a policy that requires values of one or more claim types to
    /// wildcard match one of the defined acceptable patterns.  The defined acceptable
    /// patterns are generated by the DefaultAuthorizationPolicyConvention. The 
    /// matching algorithm (which caches matching patterns for performance) is
    /// provided in the ClamPatternAuthorizationHandler class.
    /// NOTE: Requires defaultPoliciesClaimTypesKey in Configuration set to
    /// an array of claim types or null (not empty array!)
    /// NOTE: To disable the policy, set the value of the 
    /// defaultPoliciesClaimTypesKey = null
    /// <see cref="DefaultAuthorizationPolicyConvention"/>
    /// <see cref="ClaimPatternAuthorizationHandler"/>
    /// </summary>
    public class DefaultPoliciesAuthorizationPolicyProvider : IAuthorizationPolicyProvider {

        private AuthorizationOptions _options;
        private Task<AuthorizationPolicy> _cachedPolicyTask;
        private readonly IConfiguration _configuration;
        //outerkey is the scope policy (the default policy associated with the action method)
        //inner key is the pattern that matches either negatively or positively
        public ConcurrentDictionary<string, ConcurrentDictionary<string, bool>> PolicyPatternCacheSet { get; private set; }
        private readonly ILogger _logger;
        private readonly string _defaultPoliciesKey;
        private readonly string _defaultPoliciesClaimTypesKey;


        /// <summary>
        /// Constructs a new DefaultPoliciesAuthorizationPolicyProvider
        /// </summary>
        /// <param name="configuration">IConfiguration instance</param>
        /// <param name="logger">ILogger instance</param>
        /// <param name="defaultPoliciesKey">Config key for generated default policies</param>
        /// <param name="defaultPoliciesClaimTypesKey">Config key associated with array of one 
        /// or more claim types or null (not empty array!). 
        /// NOTE: To disable the policy, set the value of the defaultPoliciesClaimTypesKey = null
        /// (not empty array!)</param>
        public DefaultPoliciesAuthorizationPolicyProvider(IConfiguration configuration,
            ILogger logger, string defaultPoliciesKey,
            string defaultPoliciesClaimTypesKey) {

            _configuration = configuration;
            PolicyPatternCacheSet = new ConcurrentDictionary<string, ConcurrentDictionary<string,bool>>();
            _logger = logger;
            _defaultPoliciesKey = defaultPoliciesKey;
            _defaultPoliciesClaimTypesKey = defaultPoliciesClaimTypesKey;
        }

        /// <summary>
        /// Gets the default authorization policy.
        /// </summary>
        /// <returns>The default authorization policy.</returns>
        public Task<AuthorizationPolicy> GetDefaultPolicyAsync() {
            if (_options == null)
                BuildPolicyOptions();
            return GetCachedPolicy(ref _cachedPolicyTask, _options.DefaultPolicy);
        }


        private Task<AuthorizationPolicy> GetCachedPolicy(ref Task<AuthorizationPolicy> cachedPolicy, AuthorizationPolicy currentPolicy) {
            if (_options == null)
                BuildPolicyOptions();
            var local = cachedPolicy;
            if (local == null || local.Result != currentPolicy) {
                cachedPolicy = local = Task.FromResult(currentPolicy);
            }
            return local;
        }

        /// <summary>
        /// Gets a <see cref="AuthorizationPolicy"/> from the given <paramref name="policyName"/>
        /// </summary>
        /// <param name="policyName">The policy name to retrieve.</param>
        /// <returns>The named <see cref="AuthorizationPolicy"/>.</returns>
        public virtual Task<AuthorizationPolicy> GetPolicyAsync(string policyName) {
            // MVC caches policies specifically for this class, so this method MUST return the same policy per
            // policyName for every request or it could allow undesired access. It also must return synchronously.
            // A change to either of these behaviors would require shipping a patch of MVC as well.
            if (_options == null)
                BuildPolicyOptions();
            return Task.FromResult(_options.GetPolicy(policyName));
        }

        private void BuildPolicyOptions() {
            _logger.LogTrace("Building default policies");
            _options = new AuthorizationOptions();

            //***
            //*** Get the DefaultPolicies added to configuration 
            //*** by AddDefaultAuthorizationPolicyConvention
            //***
            List<string> policies = new List<string>();
            _configuration.Bind(_defaultPoliciesKey, policies);

            if (policies.Count > 0) {

                //retrieve claim types for default policies; throw exception
                //if the relevant config section isn't present or set to empty array or object
                var claimTypes = new List<string>();
                _configuration.BindSectionOrThrow(_defaultPoliciesClaimTypesKey, claimTypes, _logger);


                foreach (var policy in policies)
                    _options.AddPolicy(policy, builder => {
                        var policyPatternCache = PolicyPatternCacheSet.GetOrAdd(policy, new ConcurrentDictionary<string, bool>());

                        //if no claim types are registered, then add a trivial requirement
                        //which in effect bypasses security
                        if (claimTypes.Count == 0)
                            builder.AddRequirements(new AssertionRequirement(context => true));

                        //otherwise, add claim pattern requirements for each claim type
                        foreach(var claimType in claimTypes)
                            builder.Requirements.Add(new ClaimPatternAuthorizationHandler(policy, policyPatternCache, _logger, claimType));
                    });
            }

        }

        /// <summary>
        /// This is unnecessary because comprehensive policies are generated
        /// by this policy provider.
        /// </summary>
        /// <returns></returns>
        public Task<AuthorizationPolicy> GetFallbackPolicyAsync() {
            //per https://github.com/googleapis/google-api-dotnet-client/issues/1434#issuecomment-527104967
            var result = new AuthorizationPolicyBuilder();
            result = result.RequireAssertion(context =>
            {
                return true;
            });

            return Task.FromResult(result.Build());
        }

    }
}